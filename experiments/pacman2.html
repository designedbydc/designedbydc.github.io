<!DOCTYPE html>
<html>
<head>
    <title>Enhanced Pacman Game</title>
    <style>
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #000;
            position: relative;
        }
        canvas {
            border: 1px solid black;
            width: 537.6px;
            height: 595.2px;
        }
        #game-info {
            color: white;
            font-size: 24px;
            margin-bottom: 10px;
            font-family: Arial, sans-serif;
            display: flex;
            gap: 20px;
        }
        #aggressiveness-slider {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 200px;
            background: #333;
            border-radius: 10px;
            padding: 5px;
        }
        #slider-handle {
            width: 100%;
            height: 20px;
            background: #fff;
            border-radius: 5px;
            cursor: ns-resize;
            position: relative;
        }
        #restart-button {
            position: absolute;
            bottom: 20px;
            padding: 10px 20px;
            font-size: 18px;
            background: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: none;
        }
        #restart-button:hover {
            background: #ddd;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div id="game-info">
            <span id="score">Score: 0</span>
            <span id="lives">Lives: 3</span>
        </div>
        <canvas id="gameCanvas" width="448" height="496"></canvas>
        <div id="aggressiveness-slider">
            <div id="slider-handle"></div>
        </div>
        <button id="restart-button">Restart Game</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const slider = document.getElementById('aggressiveness-slider');
        const handle = document.getElementById('slider-handle');
        const restartButton = document.getElementById('restart-button');

        // Game constants
        const GRID_SIZE = 16;
        const PACMAN_SIZE = 16;
        const GHOST_SIZE = 16;
        const WALL_COLOR = '#0000FF';
        const PACMAN_COLOR = '#FFFF00';
        const GHOST_COLORS = ['#FF0000', '#00FFFF', '#FF00FF', '#FFA500'];
        const DOT_COLOR = '#FFFFFF';

        // Sounds
        const eatSound = new Audio('https://www.myinstants.com/media/sounds/pacman_chomp.mp3');
        const deathSound = new Audio('https://www.myinstants.com/media/sounds/pacman_death.mp3');

        // Initial maze layout
        const initialMaze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
            [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1],
            [1,1,1,1,1,1,2,1,1,2,2,2,2,0,0,2,2,2,2,1,1,2,1,1,1,1,1,1],
            [1,1,1,1,1,1,2,1,1,2,1,1,1,0,0,1,1,1,2,1,1,2,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,2,1,1,1,0,0,1,1,1,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        // Game state
        let maze = JSON.parse(JSON.stringify(initialMaze));
        let pacman = {
            x: GRID_SIZE * 13,
            y: GRID_SIZE * 10,
            speed: 2,
            direction: 0,
            moving: false,
            mouthAngle: 0,
            mouthOpening: true
        };
        let ghosts = [
            {x: GRID_SIZE * 1, y: GRID_SIZE * 1, speed: 1.5, direction: 0, active: false},
            {x: GRID_SIZE * 26, y: GRID_SIZE * 1, speed: 1.5, direction: 1, active: false},
            {x: GRID_SIZE * 1, y: GRID_SIZE * 12, speed: 1.5, direction: 2, active: false},
            {x: GRID_SIZE * 26, y: GRID_SIZE * 12, speed: 1.5, direction: 3, active: false}
        ];
        let score = 0;
        let lives = 3;
        let gameOver = false;
        let gameStartTime = null;
        const GHOST_DELAY = 2000;
        let ghostAggressiveness = 0.7;
        let animationFrameId = null;

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (gameOver) return;
            e.preventDefault();
            switch(e.key) {
                case 'ArrowRight': pacman.direction = 0; pacman.moving = true; break;
                case 'ArrowDown': pacman.direction = 1; pacman.moving = true; break;
                case 'ArrowLeft': pacman.direction = 2; pacman.moving = true; break;
                case 'ArrowUp': pacman.direction = 3; pacman.moving = true; break;
            }
        });

        // Slider for ghost aggressiveness
        let isDragging = false;
        const sliderHeight = slider.offsetHeight - handle.offsetHeight;
        
        handle.addEventListener('mousedown', () => isDragging = true);
        document.addEventListener('mouseup', () => isDragging = false);
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const rect = slider.getBoundingClientRect();
                let newY = e.clientY - rect.top - handle.offsetHeight/2;
                newY = Math.max(0, Math.min(newY, sliderHeight));
                handle.style.top = newY + 'px';
                ghostAggressiveness = 1 - (newY / sliderHeight);
            }
        });

        // Restart functionality
        function resetGame(fullReset = false) {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            pacman = {
                x: GRID_SIZE * 13,
                y: GRID_SIZE * 10,
                speed: 2,
                direction: 0,
                moving: false,
                mouthAngle: 0,
                mouthOpening: true
            };
            ghosts = [
                {x: GRID_SIZE * 1, y: GRID_SIZE * 1, speed: 1.5, direction: 0, active: false},
                {x: GRID_SIZE * 26, y: GRID_SIZE * 1, speed: 1.5, direction: 1, active: false},
                {x: GRID_SIZE * 1, y: GRID_SIZE * 12, speed: 1.5, direction: 2, active: false},
                {x: GRID_SIZE * 26, y: GRID_SIZE * 12, speed: 1.5, direction: 3, active: false}
            ];
            gameOver = false;
            gameStartTime = null;
            if (fullReset) {
                score = 0;
                lives = 3;
                maze = JSON.parse(JSON.stringify(initialMaze));
                scoreDisplay.textContent = `Score: ${score}`;
                livesDisplay.textContent = `Lives: ${lives}`;
            }
            restartButton.style.display = 'none';
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        restartButton.addEventListener('click', () => resetGame(true));

        function drawMaze() {
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    if (maze[y][x] === 1) {
                        ctx.fillStyle = WALL_COLOR;
                        ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    } else if (maze[y][x] === 2) {
                        ctx.beginPath();
                        ctx.arc(x * GRID_SIZE + GRID_SIZE/2, y * GRID_SIZE + GRID_SIZE/2, 2, 0, Math.PI * 2);
                        ctx.fillStyle = DOT_COLOR;
                        ctx.fill();
                        ctx.closePath();
                    }
                }
            }
        }

        function drawPacman() {
            ctx.save();
            ctx.translate(pacman.x + PACMAN_SIZE/2, pacman.y + PACMAN_SIZE/2);
            ctx.rotate(pacman.direction * Math.PI/2);
            ctx.beginPath();
            ctx.arc(0, 0, PACMAN_SIZE/2, pacman.mouthAngle, Math.PI * 2 - pacman.mouthAngle);
            ctx.lineTo(0, 0);
            ctx.fillStyle = PACMAN_COLOR;
            ctx.fill();
            ctx.closePath();
            ctx.restore();
        }

        function drawGhosts() {
            ghosts.forEach((ghost, index) => {
                if (ghost.active) {
                    ctx.beginPath();
                    ctx.arc(ghost.x + GHOST_SIZE/2, ghost.y + GHOST_SIZE/2, GHOST_SIZE/2, 0, Math.PI * 2);
                    ctx.fillStyle = GHOST_COLORS[index];
                    ctx.fill();
                    ctx.closePath();
                }
            });
        }

        function canMove(x, y) {
            // Check all four corners of Pacman
            const corners = [
                [x, y],                             // Top-left
                [x + PACMAN_SIZE - 1, y],          // Top-right
                [x, y + PACMAN_SIZE - 1],          // Bottom-left
                [x + PACMAN_SIZE - 1, y + PACMAN_SIZE - 1] // Bottom-right
            ];
            
            for (let [cornerX, cornerY] of corners) {
                const gridX = Math.floor(cornerX / GRID_SIZE);
                const gridY = Math.floor(cornerY / GRID_SIZE);
                if (gridX < 0 || gridX >= maze[0].length || 
                    gridY < 0 || gridY >= maze.length || 
                    maze[gridY][gridX] === 1) {
                    return false;
                }
            }
            return true;
        }

        function collectDot() {
            const gridX = Math.floor(pacman.x / GRID_SIZE);
            const gridY = Math.floor(pacman.y / GRID_SIZE);
            if (maze[gridY][gridX] === 2) {
                maze[gridY][gridX] = 0;
                score += 10;
                scoreDisplay.textContent = `Score: ${score}`;
                eatSound.play();
            }
        }

        function updatePacman() {
            if (!pacman.moving) return;

            let newX = pacman.x;
            let newY = pacman.y;

            switch(pacman.direction) {
                case 0: newX += pacman.speed; break; // Right
                case 1: newY += pacman.speed; break; // Down
                case 2: newX -= pacman.speed; break; // Left
                case 3: newY -= pacman.speed; break; // Up
            }

            if (canMove(newX, newY)) {
                pacman.x = newX;
                pacman.y = newY;
                collectDot();
            }

            if (pacman.moving) {
                if (pacman.mouthOpening) {
                    pacman.mouthAngle += 0.1;
                    if (pacman.mouthAngle >= 0.5) pacman.mouthOpening = false;
                } else {
                    pacman.mouthAngle -= 0.1;
                    if (pacman.mouthAngle <= 0) pacman.mouthOpening = true;
                }
            }
        }

        function updateGhosts(timestamp) {
            if (!gameStartTime) gameStartTime = timestamp;
            const elapsed = timestamp - gameStartTime;

            ghosts.forEach(ghost => {
                if (elapsed > GHOST_DELAY) {
                    ghost.active = true;
                }

                if (!ghost.active) return;

                let directionChoices = [];
                const dx = pacman.x - ghost.x;
                const dy = pacman.y - ghost.y;

                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 0) directionChoices.push(0);
                    else directionChoices.push(2);
                    if (dy > 0) directionChoices.push(1);
                    else directionChoices.push(3);
                } else {
                    if (dy > 0) directionChoices.push(1);
                    else directionChoices.push(3);
                    if (dx > 0) directionChoices.push(0);
                    else directionChoices.push(2);
                }

                if (Math.random() > ghostAggressiveness) {
                    directionChoices = [0, 1, 2, 3];
                }

                let moved = false;
                for (let dir of directionChoices) {
                    let newX = ghost.x;
                    let newY = ghost.y;
                    switch(dir) {
                        case 0: newX += ghost.speed; break;
                        case 1: newY += ghost.speed; break;
                        case 2: newX -= ghost.speed; break;
                        case 3: newY -= ghost.speed; break;
                    }
                    if (canMove(newX, newY)) {
                        ghost.x = newX;
                        ghost.y = newY;
                        ghost.direction = dir;
                        moved = true;
                        break;
                    }
                }

                if (!moved) {
                    ghost.direction = Math.floor(Math.random() * 4);
                }

                const distX = pacman.x - ghost.x;
                const distY = pacman.y - ghost.y;
                const distance = Math.sqrt(distX * distX + distY * distY);
                if (distance < PACMAN_SIZE && ghost.active) {
                    lives--;
                    livesDisplay.textContent = `Lives: ${lives}`;
                    deathSound.play();
                    if (lives > 0) {
                        resetGame(false);
                    } else {
                        gameOver = true;
                        restartButton.style.display = 'block';
                    }
                    return; // Exit to prevent multiple frame requests
                }
            });
        }

        function gameLoop(timestamp) {
            if (gameOver) {
                ctx.fillStyle = 'red';
                ctx.font = '40px Arial';
                ctx.fillText('GAME OVER', canvas.width/2 - 100, canvas.height/2);
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawMaze();
            updatePacman();
            updateGhosts(timestamp);
            drawPacman();
            drawGhosts();

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        animationFrameId = requestAnimationFrame(gameLoop);
    </script>
</body>
</html>